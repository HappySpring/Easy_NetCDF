function [starts, counts, groups, groups_source] = FUN_group_incontinuous_indices(idx)
%FUN_GROUP_INCONTINUOUS_INDICES Group incontinuous subsets of numeric array
%
%   [STARTS, COUNTS, GROUPS] = FUN_GROUP_INCONTINUOUS_INDICES(IDX) analyzes
%   a vector of numeric indices and groups them into continuous segments.
%   This is particularly useful for generating 'start' and 'count' parameters
%   for NetCDF operations (ncread/ncwrite) to process discontinuous data
%   efficiently.
%
%   [STARTS, COUNTS, GROUPS, GROUPS_SOURCE] = ... also returns the indices
%   of the input vector corresponding to each group.
%
%   INPUTS:
%     idx - (Numeric Vector) A vector of real, integer-like numbers.
%           Note: It is highly recommended to pass SORTED, UNIQUE indices
%           if the output is intended for NetCDF hyperslab operations.
%
%   OUTPUTS:
%     starts        - (Nx1 Double) The first value of each continuous group.
%     counts        - (Nx1 Double) The number of elements in each group.
%     groups        - (Nx1 Cell) The actual values for each run.
%     groups_source - (Nx1 Cell) The indices of the input 'idx' that belong
%                     to each group (mapping output back to input).
%
%   EXAMPLES:
%     % 1. Generate start/count for NetCDF reading
%     indices = [1, 2, 3, 4, 10, 11, 12, 20];
%     [st, cnt] = FUN_group_incontinuous_indices(indices);
%     % Result: st = [1; 10; 20], cnt = [4; 3; 1]
%
%     % 2. Map groups back to source indices
%     raw = [1, 2, 8, 9];
%     [~, ~, ~, src] = FUN_group_incontinuous_indices(raw);
%     % Result: src{1} = [1; 2], src{2} = [3; 4]
%
%   NOTES:
%     - A "break" in continuity is defined when diff(idx) > 1.
%     - The function accepts unsorted input, but for NetCDF logic, sorted
%       input is required to produce valid hyperslabs.
%
%   Version: 1.0
%   Author: Generated by AI assistant, modified & validated by L. Chi.

if nargin<1 || isempty(idx)
    starts = zeros(0,1);
    counts = zeros(0,1);
    groups = cell(0,1);

    return
end

idx = idx(:);
if ~isnumeric(idx) || ~isreal(idx)
    error('IDX must be a real numeric vector.');
end
source_ind = [1:length(idx)]';

% require integer-like values (indices)
if any(abs(idx - round(idx)) > eps(max(abs(idx),1)))
    error('IDX values must be integer-like indices.');
end

% idx = unique(idx); % sort and remove duplicates


dd = diff(idx);
gapIdx = find(dd>1);
start_pos = [1; gapIdx+1];
end_pos = [gapIdx; numel(idx)];

starts = idx(start_pos);
counts = end_pos - start_pos + 1;

% build groups with a simple loop (faster and clearer than arrayfun)
n = numel(start_pos);
groups = cell(n,1);
groups_source = cell(n,1);
for k=1:n
    s = start_pos(k); e = end_pos(k);
    groups{k}        = idx(s:e).';
    groups_source{k} = source_ind(s:e).';
end


end